<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>Leitor QR Code - Controle de Convidados</title>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdn.tailwindcss.com?v=3.4.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .scanner-container { position: relative; border-radius: 12px; overflow: hidden; }
        .guest-card { transition: all 0.3s ease; }
        .guest-card:hover { transform: translateY(-2px); }
        .scanned { background: linear-gradient(135deg, #10b981, #059669); }
        .pending { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .denied { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .pulse-animation { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .tab-button { transition: all 0.3s ease; }
        .tab-button.active { 
            background-color: #eff6ff; 
            color: #2563eb; 
            border-bottom-color: #2563eb; 
        }
        .tab-content { display: block; }
        .tab-content.hidden { display: none; }
        
        /* Mobile One-Hand Optimizations */
        .mobile-bottom-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 16px;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 50;
            border-top: 1px solid #e5e7eb;
        }
        
        .mobile-bottom-actions button {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 12px;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        
        .scanner-no-zoom {
            touch-action: pan-x pan-y;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .prevent-zoom {
            touch-action: manipulation;
        }
        
        /* Lock screen orientation on mobile */
        @media screen and (max-width: 768px) {
            .scanner-container {
                transform-origin: center;
            }
            
            .mobile-scanner-wrapper {
                padding-bottom: 100px; /* Space for bottom actions */
            }
        }
        
        /* Enhanced feedback animations */
        .feedback-success {
            animation: successPulse 0.6s ease-out;
        }
        
        .feedback-error {
            animation: errorShake 0.6s ease-out;
        }
        
        .feedback-warning {
            animation: warningBounce 0.6s ease-out;
        }
        
        @keyframes successPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes warningBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        /* Dark Theme */
        .dark {
            background-color: #111827;
            color: #f9fafb;
        }
        .dark .bg-white { background-color: #1f2937; }
        .dark .bg-gray-50 { background-color: #374151; }
        .dark .bg-gray-100 { background-color: #4b5563; }
        .dark .text-gray-800 { color: #f9fafb; }
        .dark .text-gray-600 { color: #d1d5db; }
        .dark .text-gray-500 { color: #9ca3af; }
        .dark .text-gray-700 { color: #e5e7eb; }
        .dark .border-gray-300 { border-color: #6b7280; }
        .dark .border-b { border-color: #4b5563; }
        .dark .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.3); }
        .dark .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2); }
        .dark .tab-button.active { 
            background-color: #1e3a8a; 
            color: #93c5fd; 
        }
        .dark .hover\:bg-gray-200:hover { background-color: #6b7280; }
        .dark .hover\:text-gray-700:hover { color: #d1d5db; }
        .dark .hover\:border-gray-300:hover { border-color: #9ca3af; }
        .dark .hover\:bg-gray-50:hover { background-color: #4b5563; }
        .dark .bg-green-50 { background-color: #064e3b; }
        .dark .divide-gray-200 > * + * { border-color: #4b5563; }

        /* Dark Gray Theme */
        .dark-gray {
            background-color: #1f2937;
            color: #f3f4f6;
        }
        .dark-gray .bg-white { background-color: #374151; }
        .dark-gray .bg-gray-50 { background-color: #4b5563; }
        .dark-gray .bg-gray-100 { background-color: #6b7280; }
        .dark-gray .text-gray-800 { color: #f3f4f6; }
        .dark-gray .text-gray-600 { color: #d1d5db; }
        .dark-gray .text-gray-500 { color: #9ca3af; }
        .dark-gray .text-gray-700 { color: #e5e7eb; }
        .dark-gray .border-gray-300 { border-color: #6b7280; }
        .dark-gray .border-b { border-color: #4b5563; }
        .dark-gray .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.25); }
        .dark-gray .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.25), 0 10px 10px -5px rgba(0, 0, 0, 0.15); }
        .dark-gray .tab-button.active { 
            background-color: #1e40af; 
            color: #93c5fd; 
        }
        .dark-gray .hover\:bg-gray-200:hover { background-color: #6b7280; }
        .dark-gray .hover\:text-gray-700:hover { color: #d1d5db; }
        .dark-gray .hover\:border-gray-300:hover { border-color: #9ca3af; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Login Screen -->
    <div id="loginScreen" class="min-h-screen flex flex-col items-center justify-center p-4 sm:p-6">
        <div class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 w-full max-w-sm sm:max-w-md">
            <div class="text-center mb-6 sm:mb-8">
                <div class="bg-blue-100 w-14 h-14 sm:w-16 sm:h-16 rounded-full flex items-center justify-center mx-auto mb-3 sm:mb-4">
                    <i class="fas fa-qrcode text-blue-600 text-xl sm:text-2xl"></i>
                </div>
                <h1 class="text-xl sm:text-2xl font-bold text-gray-800">Leitor de Código QR</h1>
                <p class="text-gray-600 mt-1 sm:mt-2 text-sm sm:text-base">Controlo de Convidados</p>
            </div>
            
            <form id="loginForm" class="space-y-4 sm:space-y-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Token do Evento</label>
                    <input type="text" id="tokenInput" 
                           class="w-full px-3 sm:px-4 py-3 text-base border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                           placeholder="Introduza o token do evento" required>
                </div>
                
                <button type="submit" id="loginBtn"
                        class="w-full bg-blue-600 text-white py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors text-base">
                    <i class="fas fa-sign-in-alt mr-2"></i>
                    Entrar
                </button>
            </form>
            
            <div id="loginError" class="hidden mt-4 p-3 bg-red-100 border border-red-300 rounded-lg text-red-700 text-sm"></div>
        </div>
        
        <!-- Créditos sutis -->
        <div class="text-center mt-8 text-xs text-gray-400">
            Created By Invites <span id="currentYear"></span>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="hidden min-h-screen">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b">
            <div class="max-w-7xl mx-auto px-3 sm:px-4 lg:px-8">
                <div class="flex justify-between items-center h-14 sm:h-16">
                    <div class="flex items-center min-w-0 flex-1">
                        <h1 class="text-lg sm:text-xl font-semibold text-gray-800 truncate" id="eventTitle">Evento</h1>
                        <span class="ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-green-100 text-green-800 rounded-full text-xs sm:text-sm font-medium" id="statusBadge">
                            Online
                        </span>
                    </div>
                    <div class="flex items-center space-x-2 sm:space-x-4">
                        <div class="text-xs sm:text-sm text-gray-600 hidden sm:block">
                            <span id="scannedCount">0</span> / <span id="totalGuests">0</span> digitalizados
                        </div>
                        <button id="logoutBtn" class="text-gray-500 hover:text-gray-700 p-2">
                            <i class="fas fa-sign-out-alt text-sm sm:text-base"></i>
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Tabs Navigation -->
        <div class="max-w-7xl mx-auto px-3 sm:px-4 lg:px-8">
            <div class="bg-white border-b">
                <div class="flex space-x-0">
                    <button id="scannerTab" class="tab-button active flex-1 px-4 py-3 text-sm sm:text-base font-medium border-b-2 border-blue-500 text-blue-600 bg-blue-50 rounded-t-lg">
                        <i class="fas fa-qrcode mr-1 sm:mr-2"></i>
                        Scanner
                    </button>
                    <button id="optionsTab" class="tab-button flex-1 px-4 py-3 text-sm sm:text-base font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 rounded-t-lg">
                        <i class="fas fa-cog mr-1 sm:mr-2"></i>
                        Opções
                    </button>
                </div>
            </div>
        </div>

        <!-- Tab Content -->
        <div class="max-w-7xl mx-auto px-3 sm:px-4 lg:px-8 py-4">
            <!-- Scanner Tab -->
            <div id="scannerTabContent" class="tab-content">
                <div class="mobile-scanner-wrapper">
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <!-- Scanner Principal -->
                        <div class="lg:col-span-2">
                            <div class="bg-white rounded-xl shadow-sm p-6">
                                <div id="scannerContainer" class="scanner-container scanner-no-zoom bg-gray-900 rounded-2xl h-[400px] flex items-center justify-center mx-auto border-4 border-gray-300 shadow-2xl">
                                    <div class="text-center text-gray-400 px-6">
                                        <i class="fas fa-qrcode text-5xl mb-4 text-gray-500"></i>
                                        <p class="text-lg font-medium">A inicializar scanner...</p>
                                        <p class="text-sm mt-2 text-gray-500">Posicione o QR na área de scan</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                    <!-- Painel Lateral -->
                    <div class="lg:col-span-1">
                        <!-- Resultado do Scan -->
                        <div class="bg-white rounded-xl shadow-sm p-6 mb-6">
                            <h3 class="font-semibold text-gray-800 mb-4 flex items-center">
                                <i class="fas fa-clipboard-check mr-2 text-blue-600"></i>
                                Resultado
                            </h3>
                            <div id="scanResult" class="hidden p-4 rounded-lg text-center border-l-4 transform transition-all duration-300"></div>
                            <div id="scanResultPlaceholder" class="text-center text-gray-400 py-8">
                                <i class="fas fa-qrcode text-3xl mb-2"></i>
                                <p class="text-sm">Aguardando scan...</p>
                            </div>
                        </div>

                        <!-- Progresso Rápido -->
                        <div class="bg-white rounded-xl shadow-sm p-6">
                            <h3 class="font-semibold text-gray-800 mb-4 flex items-center">
                                <i class="fas fa-chart-line mr-2 text-green-600"></i>
                                Progresso
                            </h3>
                            <div class="text-center mb-4">
                                <div class="text-3xl font-bold text-blue-600" id="scannerProgressText">0%</div>
                                <div class="text-sm text-gray-600">Concluído</div>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-3 mb-4">
                                <div id="scannerProgressBar" class="bg-gradient-to-r from-blue-500 to-green-500 h-3 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                            <div class="grid grid-cols-2 gap-4 text-center">
                                <div class="bg-green-50 p-3 rounded-lg">
                                    <div class="text-xl font-bold text-green-600" id="scannerScannedCount">0</div>
                                    <div class="text-xs text-green-700">Escaneados</div>
                                </div>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <div class="text-xl font-bold text-blue-600" id="scannerTotalGuestCount">0</div>
                                    <div class="text-xs text-blue-700">Total</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
                
            </div>

            <!-- Options Tab -->
            <div id="optionsTabContent" class="tab-content hidden">
                <div class="space-y-6">
                    <!-- Informações do Token -->
                    <div class="bg-white rounded-xl shadow-sm p-6 mb-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center">
                            <i class="fas fa-key mr-3 text-blue-600"></i>
                            Informações do Token
                        </h2>
                        
                        <!-- Relógio Cronometrado Principal -->
                        <div class="bg-gradient-to-br from-blue-900 to-purple-900 p-6 rounded-xl mb-6 text-white text-center">
                            <div class="flex items-center justify-center mb-3">
                                <i class="fas fa-clock text-3xl mr-3"></i>
                                <h3 class="text-xl font-bold">Tempo Restante</h3>
                            </div>
                            <div id="countdownClock" class="text-4xl font-mono font-bold mb-2">
                                <span id="countdownDays">00</span>d 
                                <span id="countdownHours">00</span>h 
                                <span id="countdownMinutes">00</span>m 
                                <span id="countdownSeconds">00</span>s
                            </div>
                            <div id="countdownStatus" class="text-sm opacity-80">Calculando tempo restante...</div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                                <div class="flex items-center mb-2">
                                    <i class="fas fa-calendar-alt text-blue-600 mr-2"></i>
                                    <h3 class="font-medium text-gray-800">Data de Validade</h3>
                                </div>
                                <div id="tokenExpiryDate" class="text-lg font-bold text-blue-600">A carregar...</div>
                                <div id="tokenExpiryCountdown" class="text-sm text-gray-600 mt-1">Calculando...</div>
                            </div>
                            <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                                <div class="flex items-center mb-2">
                                    <i class="fas fa-shield-alt text-green-600 mr-2"></i>
                                    <h3 class="font-medium text-gray-800">Status do Token</h3>
                                </div>
                                <div id="tokenStatus" class="text-lg font-bold text-green-600">Ativo</div>
                                <div class="text-sm text-gray-600 mt-1">Token válido e funcional</div>
                            </div>
                        </div>
                        <div id="expiryWarning" class="hidden mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                            <div class="flex items-center">
                                <i class="fas fa-exclamation-triangle text-yellow-600 mr-2"></i>
                                <div>
                                    <h4 class="font-medium text-yellow-800">Atenção: Token a expirar em breve!</h4>
                                    <p class="text-sm text-yellow-700 mt-1">Recomendamos que faça o download do relatório final antes da expiração.</p>
                                </div>
                            </div>
                        </div>
                        <div id="expiredWarning" class="hidden mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                            <div class="flex items-center">
                                <i class="fas fa-times-circle text-red-600 mr-2"></i>
                                <div>
                                    <h4 class="font-medium text-red-800">Token Expirado!</h4>
                                    <p class="text-sm text-red-700 mt-1">Este token já não é válido. Contacte o suporte se necessário.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Estatísticas do Evento -->
                    <div class="bg-white rounded-xl shadow-sm p-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center">
                            <i class="fas fa-chart-bar mr-3 text-blue-600"></i>
                            Estatísticas do Evento
                        </h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <div class="bg-green-50 p-4 rounded-lg text-center border border-green-200">
                                <div class="text-3xl font-bold text-green-600" id="confirmedCount">0</div>
                                <div class="text-sm text-green-700 mt-1">Confirmados</div>
                            </div>
                            <div class="bg-yellow-50 p-4 rounded-lg text-center border border-yellow-200">
                                <div class="text-3xl font-bold text-yellow-600" id="pendingCount">0</div>
                                <div class="text-sm text-yellow-700 mt-1">Pendentes</div>
                            </div>
                        </div>
                        
                        <!-- Progresso -->
                        <div class="p-6 bg-gradient-to-r from-blue-50 to-green-50 rounded-lg border border-blue-200">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="font-semibold text-gray-800 flex items-center">
                                    <i class="fas fa-chart-line mr-2 text-blue-600"></i>
                                    Progresso do Evento
                                </h3>
                                <span id="connectionStatus" class="flex items-center text-sm">
                                    <div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>
                                    Online
                                </span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-4 mb-3">
                                <div id="progressBar" class="bg-gradient-to-r from-blue-500 to-green-500 h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                            <div class="text-center">
                                <span id="progressText" class="text-lg font-medium text-gray-700">0% dos convidados digitalizados</span>
                            </div>
                        </div>
                    </div>

                    <!-- Lista de Convidados -->
                    <div class="bg-white rounded-xl shadow-sm">
                        <div class="p-6 border-b bg-gradient-to-r from-blue-50 to-purple-50">
                            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4">
                                <h2 class="text-xl font-semibold text-gray-800 flex items-center">
                                    <i class="fas fa-users mr-3 text-blue-600"></i>
                                    Lista de Convidados
                                </h2>
                                <div class="flex flex-col sm:flex-row gap-2">
                                    <input type="text" id="searchInput" placeholder="Procurar convidado..."
                                           class="px-4 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <select id="filterSelect" class="px-4 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                        <option value="all">Todos</option>
                                        <option value="scanned">Digitalizados</option>
                                        <option value="pending">Pendentes</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="overflow-hidden">
                            <div id="guestList" class="max-h-96 overflow-y-auto">
                                <table class="w-full">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr>
                                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nome</th>
                                            <th class="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="guestTableBody" class="bg-white divide-y divide-gray-200">
                                        <tr>
                                            <td colspan="2" class="text-center text-gray-500 py-8">
                                                <i class="fas fa-users text-3xl mb-2"></i>
                                                <p>A carregar lista de convidados...</p>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>



                    <!-- Configurações de Feedback -->
                    <div class="bg-white rounded-xl shadow-sm p-6 mb-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center">
                            <i class="fas fa-volume-up mr-3 text-green-600"></i>
                            Configurações de Feedback
                        </h2>
                        <div class="space-y-6">
                            <!-- Som -->
                            <div class="flex items-center justify-between p-4 bg-green-50 rounded-lg border border-green-200">
                                <div class="flex-1">
                                    <h3 class="font-medium text-gray-800 flex items-center">
                                        <i class="fas fa-volume-up mr-2 text-green-600"></i>
                                        Som
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">Feedback sonoro nos scans</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="soundToggle" class="sr-only peer" checked>
                                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                                </label>
                            </div>

                            <!-- Vibração -->
                            <div class="flex items-center justify-between p-4 bg-purple-50 rounded-lg border border-purple-200">
                                <div class="flex-1">
                                    <h3 class="font-medium text-gray-800 flex items-center">
                                        <i class="fas fa-mobile-alt mr-2 text-purple-600"></i>
                                        Vibração
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">Feedback tátil nos scans</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="vibrationToggle" class="sr-only peer" checked>
                                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                                </label>
                            </div>

                            <!-- Notificações -->
                            <div class="flex items-center justify-between p-4 bg-blue-50 rounded-lg border border-blue-200">
                                <div class="flex-1">
                                    <h3 class="font-medium text-gray-800 flex items-center">
                                        <i class="fas fa-bell mr-2 text-blue-600"></i>
                                        Notificações
                                    </h3>
                                    <p class="text-sm text-gray-600 mt-1">Alertas e marcos do evento</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="notificationsToggle" class="sr-only peer" checked>
                                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                </label>
                            </div>
                        </div>
                    </div>





                    <!-- Ações Rápidas -->
                    <div class="bg-white rounded-xl shadow-sm p-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center">
                            <i class="fas fa-bolt mr-3 text-yellow-600"></i>
                            Ações Rápidas
                        </h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                            <button id="refreshDataBtn" class="bg-gray-600 text-white py-4 px-6 rounded-lg hover:bg-gray-700 transition-colors flex items-center justify-center text-lg font-medium shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                                <i class="fas fa-refresh mr-3"></i>
                                Atualizar
                            </button>
                            <button id="syncBtn" class="bg-green-600 text-white py-4 px-6 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center text-lg font-medium shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                                <i class="fas fa-sync-alt mr-3"></i>
                                Sincronizar
                            </button>
                            <button id="exportBtn" class="bg-purple-600 text-white py-4 px-6 rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center text-lg font-medium shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                                <i class="fas fa-download mr-3"></i>
                                Exportar
                            </button>
                            <button id="undoScansBtn" class="bg-red-600 text-white py-4 px-6 rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center text-lg font-medium shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                                <i class="fas fa-undo mr-3"></i>
                                Desfazer
                            </button>
                        </div>
                        <div id="undoUsageInfo" class="mt-4 text-center text-sm text-gray-600">
                            <i class="fas fa-info-circle mr-1"></i>
                            Restam <span id="undoUsagesLeft">3</span> utilizações do botão desfazer
                        </div>
                    </div>


                </div>
            </div>
            
            <!-- Mobile Bottom Actions (One-Hand Mode) -->
            <div id="mobileBottomActions" class="mobile-bottom-actions hidden">
                <button id="nextScanBtn" class="bg-green-600 text-white hover:bg-green-700 transition-colors shadow-lg">
                    <i class="fas fa-arrow-right mr-3"></i>
                    Próximo Scan
                </button>
            </div>
        </div>
    </div>

    <script>
        // Configuração do Supabase
        const SUPABASE_URL = 'https://rnvunprjvppbjavkaoek.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJudnVucHJqdnBwYmphdmthb2VrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE2NjYzOTksImV4cCI6MjA2NzI0MjM5OX0.5E37Qm-KMmyGtGKbOINbDqMQlZlfgcQx91RQ01qslT8';
        
        // Aguardar carregamento da biblioteca Supabase
        let supabaseClient = null;
        
        // Inicializar Supabase quando a página carregar
        window.addEventListener('load', () => {
            if (typeof supabase !== 'undefined') {
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase inicializado com sucesso');
            } else {
                console.error('Biblioteca Supabase não carregada');
            }
        });

        // Estado da aplicação
        let currentClient = null;
        let guests = [];
        let scannedGuests = new Set();
        let html5QrCode = null;
        let isScanning = false;
        let scanPaused = false;
        let lastScanResult = null;
        let connectionCheckInterval = null;
        let tokenCheckInterval = null;
        let autoSyncInterval = null;
        let undoUsagesRemaining = 3;

        // Função para detectar se o nome é plural (múltiplas pessoas)
        function detectPlural(name) {
            if (!name || typeof name !== 'string') return false;
            
            const lowerName = name.toLowerCase();
            const pluralIndicators = [
                ' e ', ' and ', ' & ', ' + ', ' / ', ' - ',
                'família', 'family', 'casal', 'couple',
                'sr. e sra.', 'mr. and mrs.', 'dr. e dra.'
            ];
            
            return pluralIndicators.some(indicator => lowerName.includes(indicator));
        }

        // Função para obter informações do dispositivo
        function getDeviceInfo() {
            const userAgent = navigator.userAgent;
            let deviceType = 'Desktop';
            let browser = 'Desconhecido';
            let os = 'Desconhecido';
            
            // Detectar tipo de dispositivo
            if (/Android/i.test(userAgent)) {
                deviceType = 'Android';
                os = 'Android';
            } else if (/iPhone|iPad|iPod/i.test(userAgent)) {
                deviceType = /iPad/i.test(userAgent) ? 'iPad' : 'iPhone';
                os = 'iOS';
            } else if (/Windows/i.test(userAgent)) {
                os = 'Windows';
            } else if (/Mac/i.test(userAgent)) {
                os = 'macOS';
            } else if (/Linux/i.test(userAgent)) {
                os = 'Linux';
            }
            
            // Detectar navegador
            if (/Chrome/i.test(userAgent) && !/Edge/i.test(userAgent)) {
                browser = 'Chrome';
            } else if (/Firefox/i.test(userAgent)) {
                browser = 'Firefox';
            } else if (/Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)) {
                browser = 'Safari';
            } else if (/Edge/i.test(userAgent)) {
                browser = 'Edge';
            }
            
            return `${deviceType} - ${browser} (${os})`;
        }

        // Função para obter IP do usuário (aproximado)
        async function getUserIP() {
            try {
                // Usar serviço público para obter IP
                const response = await fetch('https://api.ipify.org?format=json', {
                    timeout: 3000
                });
                const data = await response.json();
                return data.ip || 'Desconhecido';
            } catch (error) {
                // Se falhar, tentar método alternativo
                try {
                    const response = await fetch('https://httpbin.org/ip', {
                        timeout: 3000
                    });
                    const data = await response.json();
                    return data.origin || 'Desconhecido';
                } catch (error2) {
                    return 'Desconhecido';
                }
            }
        }
        
        // Configurações
        let settings = {
            soundEnabled: true,
            vibrationEnabled: true,
            notificationsEnabled: true
        };

        // Elementos DOM
        const loginScreen = document.getElementById('loginScreen');
        const mainApp = document.getElementById('mainApp');
        const loginForm = document.getElementById('loginForm');
        const tokenInput = document.getElementById('tokenInput');
        const loginError = document.getElementById('loginError');
        const eventTitle = document.getElementById('eventTitle');
        const scannedCount = document.getElementById('scannedCount');
        const totalGuests = document.getElementById('totalGuests');

        const scannerContainer = document.getElementById('scannerContainer');
        const scanResult = document.getElementById('scanResult');
        const nextScanContainer = document.getElementById('nextScanContainer');
        const nextScanBtn = document.getElementById('nextScanBtn');
        const guestList = document.getElementById('guestList');
        const searchInput = document.getElementById('searchInput');
        const filterSelect = document.getElementById('filterSelect');
        const confirmedCount = document.getElementById('confirmedCount');
        const pendingCount = document.getElementById('pendingCount');
        const scanLimit = document.getElementById('scanLimit');
        const scanUsed = document.getElementById('scanUsed');
        const connectionStatus = document.getElementById('connectionStatus');
        const logoutBtn = document.getElementById('logoutBtn');
        const syncBtn = document.getElementById('syncBtn');
        const exportBtn = document.getElementById('exportBtn');
        
        // Elementos das abas - serão inicializados após DOM carregar
        let scannerTab, scannerTabContent, quickScanBtn, refreshDataBtn, progressBar, progressText;
        let scannerProgressBar, scannerProgressText, scannerScannedCount, scannerTotalGuestCount;
        let optionsTab, optionsTabContent;

        // Estado da conexão
        let isOnline = true;
        let wasOffline = false;

        // Verificar conexão real com internet (não só status do navegador)
        async function checkRealConnection() {
            if (!navigator.onLine) {
                return false;
            }
            
            try {
                // Tentar fazer uma requisição real para verificar conectividade
                const response = await fetch('https://www.google.com/favicon.ico', {
                    method: 'HEAD',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    timeout: 5000
                });
                return true;
            } catch (error) {
                return false;
            }
        }

        // Verificar se token ainda é válido
        async function checkTokenValidity() {
            if (!currentClient || !supabaseClient || !isOnline) return false;
            
            try {
                const { data, error } = await supabaseClient
                    .from('clientes')
                    .select('*')
                    .eq('token', currentClient.token)
                    .single();
                
                // Verificar se token não expirou (validade em timestamp)
                if (data && data.validade) {
                    const now = Math.floor(Date.now() / 1000);
                    if (now > data.validade) {
                        return false; // Token expirado
                    }
                }
                
                return !error && data;
            } catch (error) {
                return false;
            }
        }

        // Atualizar status de conexão e interface
        function updateConnectionStatus(online) {
            const statusElement = connectionStatus;
            const statusBadge = document.getElementById('statusBadge');
            
            if (online) {
                statusElement.innerHTML = '<div class="w-2 h-2 bg-green-500 rounded-full mr-2"></div>Online';
                statusElement.className = 'flex items-center text-sm text-green-700';
                statusBadge.innerHTML = 'Online';
                statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-green-100 text-green-800 rounded-full text-xs sm:text-sm font-medium';
                
                // Reativar botões que precisam de internet
                enableOnlineFeatures();
                
                // Se estava offline e agora está online, sincronizar dados
                if (wasOffline) {
                    wasOffline = false;
                    autoSyncAfterReconnection();
                }
            } else {
                statusElement.innerHTML = '<div class="w-2 h-2 bg-red-500 rounded-full mr-2"></div>Sem Internet';
                statusElement.className = 'flex items-center text-sm text-red-700';
                statusBadge.innerHTML = 'Sem Internet';
                statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-red-100 text-red-800 rounded-full text-xs sm:text-sm font-medium';
                
                // Desativar funcionalidades que precisam de internet
                disableOnlineFeatures();
                wasOffline = true;
                
                // Parar scanner se estiver ativo
                if (isScanning) {
                    stopScanner();
                }
            }
            
            isOnline = online;
        }

        // Ativar funcionalidades online
        function enableOnlineFeatures() {
            // Reativar botões
            const onlineButtons = [
                document.getElementById('syncBtn'),
                document.getElementById('refreshDataBtn')
            ];
            
            onlineButtons.forEach(btn => {
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            });
            
            // Iniciar scanner automaticamente quando voltar online
            if (!isScanning && currentClient) {
                setTimeout(() => {
                    startScanner();
                }, 1000);
            }
        }

        // Desativar funcionalidades que precisam de internet
        function disableOnlineFeatures() {
            // Desativar botões que precisam de internet
            const onlineButtons = [
                document.getElementById('syncBtn'),
                document.getElementById('refreshDataBtn')
            ];
            
            onlineButtons.forEach(btn => {
                if (btn) {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                }
            });
        }

        // Sincronização automática após reconexão
        async function autoSyncAfterReconnection() {
            try {
                console.log('Reconectado! Sincronizando dados...');
                await loadSession();
                console.log('Dados sincronizados automaticamente após reconexão');
            } catch (error) {
                console.error('Erro na sincronização automática:', error);
            }
        }

        // Sincronização automática silenciosa
        async function autoSync() {
            try {
                const previousGuestCount = guests.length;
                await loadSession();
                
                // Só mostrar notificação se encontrou novos convidados
                if (guests.length > previousGuestCount) {
                    const newGuests = guests.length - previousGuestCount;
                    showNotification(`${newGuests} novo${newGuests > 1 ? 's' : ''} convidado${newGuests > 1 ? 's' : ''} encontrado${newGuests > 1 ? 's' : ''}!`, 'info');
                }
            } catch (error) {
                // Sincronização silenciosa - não mostrar erros
                console.error('Erro na sincronização automática:', error);
            }
        }

        // Login
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Usar token real se estiver mascarado, senão usar o valor digitado
            const token = (tokenInput.value === '********' && realToken) ? realToken : tokenInput.value.trim();
            
            if (!token) return;
            
            const connectionStatus = await checkRealConnection();
            if (!connectionStatus) {
                loginError.textContent = 'Sem conexão com a internet';
                loginError.classList.remove('hidden');
                return;
            }
            
            try {
                loginError.classList.add('hidden');
                document.getElementById('loginBtn').innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Entrando...';
                
                // Verificar se Supabase está inicializado
                if (!supabaseClient) {
                    throw new Error('Sistema não inicializado. Recarregue a página.');
                }
                
                // Validar token no Supabase (apenas validação básica)
                const { data: client, error } = await supabaseClient
                    .from('clientes')
                    .select('id, nome, token, validade, limite_scans, scans_usados')
                    .eq('token', token)
                    .single();
                
                if (error || !client) {
                    // Para teste, criar dados fictícios se token for "TESTE"
                    if (token === 'TESTE') {
                        currentClient = {
                            id: 1,
                            nome: 'Evento de Teste',
                            token: 'TESTE',
                            validade: null,
                            limite_scans: null,
                            scans_usados: 0,
                            dispositivos: 'teste'
                        };
                        
                        // Dados de convidados fictícios
                        guests = [
                            { id: 1, nome: 'João Silva', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR001' },
                            { id: 2, nome: 'Maria Santos', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR002' },
                            { id: 3, nome: 'Pedro Costa', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR003' },
                            { id: 4, nome: 'Ana Oliveira', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR004' },
                            { id: 5, nome: 'Carlos Lima', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR005' },
                            { id: 6, nome: 'Sofia Rodrigues', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR006' },
                            { id: 7, nome: 'Miguel Ferreira', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR007' },
                            { id: 8, nome: 'Catarina Alves', token_cliente: 'TESTE', status: 'pendente', codigo: 'QR008' }
                        ];
                        
                        // Guardar token para próximas sessões
                        localStorage.setItem('eventToken', token);
                        
                        scannedGuests = new Set();
                        
                        // Mostrar app imediatamente
                        showMainApp();
                        startMonitoring();
                        
                        // Carregar dados em background
                        setTimeout(() => {
                            updateUI();
                            updateTokenInfo();
                            renderGuestList();
                        }, 100);
                        return;
                    }
                    throw new Error('Token inválido ou expirado');
                }
                
                currentClient = client;
                
                // Guardar token para próximas sessões
                localStorage.setItem('eventToken', token);
                
                // Mostrar app imediatamente com dados básicos
                showMainApp();
                startMonitoring();
                
                // Carregar dados completos em background
                loadSessionInBackground();
                
            } catch (error) {
                loginError.textContent = error.message;
                loginError.classList.remove('hidden');
            } finally {
                document.getElementById('loginBtn').innerHTML = '<i class="fas fa-sign-in-alt mr-2"></i>Entrar';
            }
        });

        // Iniciar monitoramento
        function startMonitoring() {
            // Verificar conexão real a cada 3 segundos
            connectionCheckInterval = setInterval(async () => {
                const currentConnectionStatus = await checkRealConnection();
                
                // Só atualizar se o status mudou
                if (currentConnectionStatus !== isOnline) {
                    updateConnectionStatus(currentConnectionStatus);
                }
            }, 3000);
            
            // Verificar validade do token a cada 30 segundos (só se online)
            tokenCheckInterval = setInterval(async () => {
                if (isOnline) {
                    const isValid = await checkTokenValidity();
                    if (!isValid) {
                        showNotification('Token expirado! A redireccionar para o login...', 'error');
                        setTimeout(() => {
                            logout();
                        }, 2000);
                    } else {
                        // Atualizar informações do token periodicamente
                        updateTokenInfo();
                    }
                }
            }, 30000);
            
            // Atualizar cronómetro a cada segundo
            setInterval(() => {
                if (currentClient && currentClient.validade) {
                    updateCountdownClock(new Date(currentClient.validade * 1000));
                } else if (currentClient) {
                    updateCountdownClock(null);
                }
            }, 1000);
            
            // Sincronização automática a cada 10 segundos
            autoSyncInterval = setInterval(async () => {
                if (isOnline && currentClient) {
                    await autoSync();
                }
            }, 10000);
            
            // Listeners para eventos de conexão do navegador
            window.addEventListener('online', async () => {
                // Verificar conexão real quando navegador diz que está online
                const realConnection = await checkRealConnection();
                if (realConnection && !isOnline) {
                    updateConnectionStatus(true);
                }
            });
            
            window.addEventListener('offline', () => {
                // Quando navegador detecta offline, atualizar imediatamente
                if (isOnline) {
                    updateConnectionStatus(false);
                }
            });
        }

        // Parar monitoramento
        function stopMonitoring() {
            if (connectionCheckInterval) clearInterval(connectionCheckInterval);
            if (tokenCheckInterval) clearInterval(tokenCheckInterval);
            if (autoSyncInterval) clearInterval(autoSyncInterval);
        }

        // Carregar sessão completa (versão original)
        async function loadSession() {
            try {
                if (!supabaseClient) {
                    throw new Error('Cliente Supabase não inicializado');
                }
                
                // Verificar se currentClient existe
                if (!currentClient || !currentClient.token) {
                    throw new Error('Cliente não inicializado');
                }
                
                // Carregar usos restantes do desfazer do Supabase (fonte única da verdade)
                const { data: clientData, error: clientError } = await supabaseClient
                    .from('clientes')
                    .select('undo_usages_remaining')
                    .eq('token', currentClient.token)
                    .single();
                
                if (clientError) {
                    console.error('Erro ao carregar dados do cliente:', clientError);
                    // Se não conseguir carregar do Supabase, usar valor padrão
                    undoUsagesRemaining = 3;
                } else {
                    // Se o campo não existir na base de dados, inicializar com 3
                    undoUsagesRemaining = clientData.undo_usages_remaining !== null ? 
                        clientData.undo_usages_remaining : 3;
                    
                    // Se for a primeira vez, atualizar o campo na base de dados
                    if (clientData.undo_usages_remaining === null) {
                        await supabaseClient
                            .from('clientes')
                            .update({ undo_usages_remaining: 3 })
                            .eq('token', currentClient.token);
                        undoUsagesRemaining = 3;
                    }
                }
                
                // Carregar convidados usando token_cliente
                const { data: guestData, error: guestError } = await supabaseClient
                    .from('convidados')
                    .select('*')
                    .eq('token_cliente', currentClient.token);
                
                if (guestError) throw guestError;
                
                guests = guestData || [];
                
                // Sincronizar convidados com histórico (backup automático)
                await syncGuestsToHistory();
                
                // Carregar scans em tempo real (nova tabela mais detalhada)
                const { data: realtimeScanData, error: realtimeScanError } = await supabaseClient
                    .from('scans_realtime')
                    .select('*')
                    .eq('token_cliente', currentClient.token)
                    .order('data_scan', { ascending: false });
                
                // Fallback para logs antigos se scans_realtime estiver vazio
                let scanData = realtimeScanData;
                if (!realtimeScanData || realtimeScanData.length === 0) {
                    const { data: legacyScanData, error: legacyScanError } = await supabaseClient
                        .from('logs')
                        .select('*')
                        .eq('token', currentClient.token)
                        .eq('status', 'escaneado');
                    
                    if (!legacyScanError && legacyScanData) {
                        scanData = legacyScanData.map(log => ({
                            codigo_convidado: log.dispositivo,
                            token_cliente: log.token,
                            data_scan: log.data,
                            dispositivo: 'Leitor QR',
                            ip_address: null
                        }));
                    }
                }
                
                // Criar set de códigos já escaneados
                scannedGuests = new Set();
                if (scanData && Array.isArray(scanData)) {
                    scanData.forEach(scan => {
                        if (scan && scan.codigo_convidado) {
                            // Encontrar convidado pelo código
                            const guest = guests.find(g => g && g.codigo === scan.codigo_convidado);
                            if (guest && guest.id) {
                                scannedGuests.add(guest.id);
                            }
                        }
                    });
                }
                
                // Aguardar um pouco para garantir que DOM está pronto
                setTimeout(() => {
                    updateUI();
                    updateTokenInfo();
                    updateUndoButton();
                    checkMilestones();
                }, 50);
                
            } catch (error) {
                console.error('Erro ao carregar sessão:', error);
                showNotification('Erro ao carregar dados', 'error');
            }
        }

        // Carregar sessão em background (versão otimizada para login rápido)
        async function loadSessionInBackground() {
            try {
                // Mostrar indicador de carregamento sutil
                const statusBadge = document.getElementById('statusBadge');
                if (statusBadge) {
                    statusBadge.innerHTML = 'Carregando...';
                    statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full text-xs sm:text-sm font-medium';
                }
                
                // Carregar dados básicos primeiro (convidados)
                const { data: guestData, error: guestError } = await supabaseClient
                    .from('convidados')
                    .select('id, nome, codigo, token_cliente, status')
                    .eq('token_cliente', currentClient.token);
                
                if (!guestError && guestData) {
                    guests = guestData;
                    
                    // Atualizar interface com dados básicos
                    updateUI();
                    
                    // Atualizar status
                    if (statusBadge) {
                        statusBadge.innerHTML = 'Sincronizando...';
                        statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs sm:text-sm font-medium';
                    }
                }
                
                // Carregar scans em paralelo
                const [realtimeScanResult, legacyScanResult, clientDataResult] = await Promise.allSettled([
                    supabaseClient
                        .from('scans_realtime')
                        .select('codigo_convidado, data_scan')
                        .eq('token_cliente', currentClient.token),
                    supabaseClient
                        .from('logs')
                        .select('dispositivo, data')
                        .eq('token', currentClient.token)
                        .eq('status', 'escaneado'),
                    supabaseClient
                        .from('clientes')
                        .select('undo_usages_remaining')
                        .eq('token', currentClient.token)
                        .single()
                ]);
                
                // Processar scans
                let scanData = [];
                if (realtimeScanResult.status === 'fulfilled' && realtimeScanResult.value.data) {
                    scanData = realtimeScanResult.value.data;
                } else if (legacyScanResult.status === 'fulfilled' && legacyScanResult.value.data) {
                    scanData = legacyScanResult.value.data.map(log => ({
                        codigo_convidado: log.dispositivo,
                        data_scan: log.data
                    }));
                }
                
                // Atualizar scannedGuests
                scannedGuests = new Set();
                if (scanData && Array.isArray(scanData)) {
                    scanData.forEach(scan => {
                        if (scan && scan.codigo_convidado) {
                            const guest = guests.find(g => g && g.codigo === scan.codigo_convidado);
                            if (guest && guest.id) {
                                scannedGuests.add(guest.id);
                            }
                        }
                    });
                }
                
                // Processar dados do cliente
                if (clientDataResult.status === 'fulfilled' && clientDataResult.value.data) {
                    const clientData = clientDataResult.value.data;
                    undoUsagesRemaining = clientData.undo_usages_remaining !== null ? 
                        clientData.undo_usages_remaining : 3;
                    
                    if (clientData.undo_usages_remaining === null) {
                        // Atualizar em background sem bloquear
                        supabaseClient
                            .from('clientes')
                            .update({ undo_usages_remaining: 3 })
                            .eq('token', currentClient.token)
                            .then(() => {
                                undoUsagesRemaining = 3;
                                updateUndoButton();
                            });
                    }
                } else {
                    undoUsagesRemaining = 3;
                }
                
                // Atualizar interface final
                updateUI();
                updateTokenInfo();
                updateUndoButton();
                
                // Sincronização com histórico em background (não bloquear)
                syncGuestsToHistory().catch(error => {
                    console.error('Erro na sincronização de histórico (background):', error);
                });
                
                // Atualizar status final
                if (statusBadge) {
                    statusBadge.innerHTML = 'Online';
                    statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-green-100 text-green-800 rounded-full text-xs sm:text-sm font-medium';
                }
                
            } catch (error) {
                console.error('Erro ao carregar sessão em background:', error);
                
                // Em caso de erro, tentar carregar dados básicos
                guests = [];
                scannedGuests = new Set();
                undoUsagesRemaining = 3;
                
                updateUI();
                
                // Atualizar status de erro
                const statusBadge = document.getElementById('statusBadge');
                if (statusBadge) {
                    statusBadge.innerHTML = 'Erro';
                    statusBadge.className = 'ml-2 sm:ml-3 px-2 sm:px-3 py-1 bg-red-100 text-red-800 rounded-full text-xs sm:text-sm font-medium';
                }
                
                showNotification('Alguns dados podem não estar atualizados', 'warning');
            }
        }

        // Sincronizar convidados com histórico (backup automático)
        async function syncGuestsToHistory() {
            try {
                if (!guests || guests.length === 0) return;
                
                // Para cada convidado ativo, garantir que existe no histórico
                for (const guest of guests) {
                    if (!guest || !guest.codigo || !guest.nome) continue;
                    
                    // Verificar se já existe no histórico
                    const { data: existingHistory } = await supabaseClient
                        .from('convidados_historico')
                        .select('id')
                        .eq('codigo', guest.codigo)
                        .eq('token_cliente', guest.token_cliente)
                        .eq('excluido', false)
                        .single();
                    
                    // Se não existe, criar entrada no histórico
                    if (!existingHistory) {
                        await supabaseClient
                            .from('convidados_historico')
                            .insert({
                                codigo: guest.codigo,
                                nome: guest.nome,
                                token_cliente: guest.token_cliente,
                                status: 'ativo',
                                excluido: false
                            });
                    }
                }
                
                console.log('Sincronização com histórico concluída');
            } catch (error) {
                console.error('Erro ao sincronizar histórico:', error);
                // Não falhar a sessão por erro de sincronização
            }
        }

        // Mostrar app principal
        function showMainApp() {
            loginScreen.classList.add('hidden');
            mainApp.classList.remove('hidden');
            eventTitle.textContent = currentClient.nome || 'Evento';
            
            // Iniciar scanner automaticamente
            setTimeout(() => {
                if (isOnline) {
                    startScanner();
                }
            }, 500);
        }

        // Controle das abas
        function switchTab(tabName) {
            // Verificar se elementos existem antes de manipular
            if (!scannerTab || !optionsTab || !scannerTabContent || !optionsTabContent) {
                console.error('Elementos das abas não encontrados');
                return;
            }
            
            // Remover classe active de todas as abas
            scannerTab.classList.remove('active', 'bg-blue-50', 'text-blue-600', 'border-blue-500');
            scannerTab.classList.add('text-gray-500', 'border-transparent');
            
            optionsTab.classList.remove('active', 'bg-blue-50', 'text-blue-600', 'border-blue-500');
            optionsTab.classList.add('text-gray-500', 'border-transparent');
            
            // Esconder todo o conteúdo das abas
            scannerTabContent.classList.add('hidden');
            optionsTabContent.classList.add('hidden');
            
            // Ativar aba selecionada
            if (tabName === 'scanner') {
                scannerTab.classList.add('active', 'bg-blue-50', 'text-blue-600', 'border-blue-500');
                scannerTab.classList.remove('text-gray-500', 'border-transparent');
                scannerTabContent.classList.remove('hidden');
            } else if (tabName === 'options') {
                optionsTab.classList.add('active', 'bg-blue-50', 'text-blue-600', 'border-blue-500');
                optionsTab.classList.remove('text-gray-500', 'border-transparent');
                optionsTabContent.classList.remove('hidden');
            }
        }

        // Atualizar informações do token
        function updateTokenInfo() {
            try {
                if (!currentClient || !currentClient.validade) {
                    document.getElementById('tokenExpiryDate').textContent = 'Não definida';
                    document.getElementById('tokenExpiryCountdown').textContent = 'Token sem data de expiração';
                    document.getElementById('tokenStatus').textContent = 'Ativo';
                    
                    // Atualizar cronómetro para token sem validade
                    updateCountdownClock(null);
                    return;
                }
                
                const now = new Date();
                const expiryDate = new Date(currentClient.validade * 1000); // Converter timestamp para data
                const timeDiff = expiryDate.getTime() - now.getTime();
                const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
                
                // Atualizar cronómetro principal
                updateCountdownClock(expiryDate);
                
                // Atualizar data de validade
                document.getElementById('tokenExpiryDate').textContent = expiryDate.toLocaleDateString('pt-PT', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Atualizar countdown
                if (daysDiff > 0) {
                    document.getElementById('tokenExpiryCountdown').textContent = `Expira em ${daysDiff} dia${daysDiff > 1 ? 's' : ''}`;
                } else if (daysDiff === 0) {
                    document.getElementById('tokenExpiryCountdown').textContent = 'Expira hoje!';
                } else {
                    document.getElementById('tokenExpiryCountdown').textContent = `Expirou há ${Math.abs(daysDiff)} dia${Math.abs(daysDiff) > 1 ? 's' : ''}`;
                }
                
                // Atualizar status e avisos
                const tokenStatusEl = document.getElementById('tokenStatus');
                const expiryWarningEl = document.getElementById('expiryWarning');
                const expiredWarningEl = document.getElementById('expiredWarning');
                
                if (daysDiff <= 0) {
                    // Token expirado
                    tokenStatusEl.textContent = 'Expirado';
                    tokenStatusEl.className = 'text-lg font-bold text-red-600';
                    expiryWarningEl.classList.add('hidden');
                    expiredWarningEl.classList.remove('hidden');
                } else if (daysDiff <= 4) {
                    // Token a expirar em breve (1-4 dias)
                    tokenStatusEl.textContent = 'A Expirar';
                    tokenStatusEl.className = 'text-lg font-bold text-yellow-600';
                    expiryWarningEl.classList.remove('hidden');
                    expiredWarningEl.classList.add('hidden');
                    
                    // Mostrar notificação de lembrete para download do relatório
                    if (daysDiff <= 4 && daysDiff >= 1) {
                        showExpiryReminder(daysDiff);
                    }
                } else {
                    // Token ativo
                    tokenStatusEl.textContent = 'Ativo';
                    tokenStatusEl.className = 'text-lg font-bold text-green-600';
                    expiryWarningEl.classList.add('hidden');
                    expiredWarningEl.classList.add('hidden');
                }
                
            } catch (error) {
                console.error('Erro ao atualizar informações do token:', error);
            }
        }
        
        // Atualizar cronómetro principal
        function updateCountdownClock(expiryDate) {
            const daysEl = document.getElementById('countdownDays');
            const hoursEl = document.getElementById('countdownHours');
            const minutesEl = document.getElementById('countdownMinutes');
            const secondsEl = document.getElementById('countdownSeconds');
            const statusEl = document.getElementById('countdownStatus');
            const clockEl = document.getElementById('countdownClock');
            
            if (!expiryDate) {
                // Token sem validade
                daysEl.textContent = '∞';
                hoursEl.textContent = '∞';
                minutesEl.textContent = '∞';
                secondsEl.textContent = '∞';
                statusEl.textContent = 'Token sem data de expiração';
                clockEl.parentElement.className = 'bg-gradient-to-br from-green-600 to-blue-600 p-6 rounded-xl mb-6 text-white text-center';
                return;
            }
            
            const now = new Date();
            const timeDiff = expiryDate.getTime() - now.getTime();
            
            if (timeDiff <= 0) {
                // Token expirado
                daysEl.textContent = '00';
                hoursEl.textContent = '00';
                minutesEl.textContent = '00';
                secondsEl.textContent = '00';
                statusEl.textContent = 'TOKEN EXPIRADO!';
                clockEl.parentElement.className = 'bg-gradient-to-br from-red-600 to-red-800 p-6 rounded-xl mb-6 text-white text-center animate-pulse';
                return;
            }
            
            // Calcular tempo restante
            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);
            
            // Atualizar display
            daysEl.textContent = days.toString().padStart(2, '0');
            hoursEl.textContent = hours.toString().padStart(2, '0');
            minutesEl.textContent = minutes.toString().padStart(2, '0');
            secondsEl.textContent = seconds.toString().padStart(2, '0');
            
            // Atualizar status e cores baseado no tempo restante
            if (days <= 0) {
                statusEl.textContent = 'ÚLTIMO DIA! Faça o download do relatório agora!';
                clockEl.parentElement.className = 'bg-gradient-to-br from-red-500 to-red-700 p-6 rounded-xl mb-6 text-white text-center animate-pulse';
            } else if (days <= 1) {
                statusEl.textContent = 'Menos de 2 dias restantes - Ação urgente necessária!';
                clockEl.parentElement.className = 'bg-gradient-to-br from-orange-500 to-red-500 p-6 rounded-xl mb-6 text-white text-center';
            } else if (days <= 3) {
                statusEl.textContent = 'Poucos dias restantes - Prepare o download do relatório';
                clockEl.parentElement.className = 'bg-gradient-to-br from-yellow-500 to-orange-500 p-6 rounded-xl mb-6 text-white text-center';
            } else if (days <= 7) {
                statusEl.textContent = 'Uma semana ou menos - Monitore o prazo';
                clockEl.parentElement.className = 'bg-gradient-to-br from-blue-500 to-purple-500 p-6 rounded-xl mb-6 text-white text-center';
            } else {
                statusEl.textContent = 'Token ativo - Tempo suficiente disponível';
                clockEl.parentElement.className = 'bg-gradient-to-br from-green-500 to-blue-500 p-6 rounded-xl mb-6 text-white text-center';
            }
        }
        
        // Mostrar lembrete de expiração
        function showExpiryReminder(daysLeft) {
            // Verificar se já mostrou o lembrete hoje
            const today = new Date().toDateString();
            const lastReminderDate = localStorage.getItem(`lastExpiryReminder_${currentClient.token}`);
            
            if (lastReminderDate === today) {
                return; // Já mostrou hoje
            }
            
            // Marcar que mostrou hoje
            localStorage.setItem(`lastExpiryReminder_${currentClient.token}`, today);
            
            // Mostrar notificação personalizada baseada nos dias restantes
            let message = '';
            if (daysLeft === 1) {
                message = '⚠️ ÚLTIMO DIA! O seu token expira amanhã. Faça o download do relatório final agora!';
            } else if (daysLeft === 2) {
                message = '⚠️ ATENÇÃO! O seu token expira em 2 dias. Recomendamos fazer o download do relatório final.';
            } else if (daysLeft === 3) {
                message = '📋 LEMBRETE: O seu token expira em 3 dias. Considere fazer o download do relatório final.';
            } else if (daysLeft === 4) {
                message = '📅 AVISO: O seu token expira em 4 dias. Prepare-se para fazer o download do relatório final.';
            }
            
            if (message) {
                showNotification(message, 'warning', 8000); // Mostrar por 8 segundos
            }
        }

        // Atualizar interface
        function updateUI() {
            try {
                // Verificar se arrays existem e são válidos
                if (!Array.isArray(guests)) guests = [];
                if (!scannedGuests || typeof scannedGuests.size !== 'number') scannedGuests = new Set();
                
                const guestCount = guests.length;
                const scannedSize = scannedGuests.size;
                
                // Verificar se elementos existem antes de atualizar
                const totalGuestsEl = document.getElementById('totalGuests');
                const scannedCountEl = document.getElementById('scannedCount');
                
                if (totalGuestsEl) totalGuestsEl.textContent = guestCount;
                if (scannedCountEl) scannedCountEl.textContent = scannedSize;
                
                const confirmed = guests.filter(g => g && g.id && scannedGuests.has(g.id)).length;
                const pending = guestCount - confirmed;
                
                // Atualizar estatísticas principais
                const confirmedCountEl = document.getElementById('confirmedCount');
                const pendingCountEl = document.getElementById('pendingCount');
                
                if (confirmedCountEl) confirmedCountEl.textContent = confirmed;
                if (pendingCountEl) pendingCountEl.textContent = pending;
                
                // Atualizar barra de progresso (dashboard)
                const progressPercentage = guestCount > 0 ? Math.round((confirmed / guestCount) * 100) : 0;
                const progressBarEl = document.getElementById('progressBar');
                const progressTextEl = document.getElementById('progressText');
                
                if (progressBarEl) progressBarEl.style.width = `${progressPercentage}%`;
                if (progressTextEl) progressTextEl.textContent = `${progressPercentage}% dos convidados digitalizados`;
                
                // Atualizar barra de progresso do scanner
                const scannerProgressBarEl = document.getElementById('scannerProgressBar');
                const scannerProgressTextEl = document.getElementById('scannerProgressText');
                const scannerScannedCountEl = document.getElementById('scannerScannedCount');
                const scannerTotalGuestCountEl = document.getElementById('scannerTotalGuestCount');
                
                if (scannerProgressBarEl) scannerProgressBarEl.style.width = `${progressPercentage}%`;
                if (scannerProgressTextEl) scannerProgressTextEl.textContent = `${progressPercentage}%`;
                if (scannerScannedCountEl) scannerScannedCountEl.textContent = confirmed;
                if (scannerTotalGuestCountEl) scannerTotalGuestCountEl.textContent = guestCount;
                
                // Renderizar lista de convidados
                renderGuestList();
                
            } catch (error) {
                console.error('Erro ao atualizar interface:', error);
            }
        }

        // Verificar marcos e notificações
        function checkMilestones() {
            const scannedCount = scannedGuests.size;
            const totalCount = guests.length;
            
            // Marcos de quantidade
            if (scannedCount === 10) {
                showNotification('🎉 10 convidados digitalizados!', 'success');
            } else if (scannedCount === 50) {
                showNotification('🚀 50 convidados digitalizados!', 'success');
            } else if (scannedCount === 100) {
                showNotification('💯 100 convidados digitalizados!', 'success');
            }
            
            // Capacidade do evento (80%)
            if (totalCount > 0 && (scannedCount / totalCount) >= 0.8) {
                showNotification('⚠️ 80% da capacidade atingida!', 'warning');
            }
        }

        // Sistema de notificações
        function showNotification(message, type = 'info', duration = 4000) {
            // Verificar se notificações estão ativadas
            if (!settings.notificationsEnabled) {
                return;
            }
            
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm transform transition-all duration-300 translate-x-full`;
            
            const colors = {
                success: 'bg-green-500 text-white',
                error: 'bg-red-500 text-white',
                warning: 'bg-yellow-500 text-white',
                info: 'bg-blue-500 text-white'
            };
            
            notification.className += ` ${colors[type]}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animar entrada
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);
            
            // Remover após duração
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, duration);
        }

        // Renderizar lista de convidados
        function renderGuestList() {
            try {
                const guestTableBody = document.getElementById('guestTableBody');
                
                // Verificar se elemento existe
                if (!guestTableBody) {
                    console.error('Elemento guestTableBody não encontrado');
                    return;
                }
                
                // Verificar se há convidados e se é um array válido
                if (!Array.isArray(guests) || guests.length === 0) {
                    guestTableBody.innerHTML = `
                        <tr>
                            <td colspan="2" class="text-center text-gray-500 py-8">
                                <i class="fas fa-users text-3xl mb-2"></i>
                                <p>Nenhum convidado encontrado</p>
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                // Obter valores de pesquisa e filtro com verificação de segurança
                const searchInputEl = document.getElementById('searchInput');
                const filterSelectEl = document.getElementById('filterSelect');
                
                const searchTerm = (searchInputEl && searchInputEl.value) ? searchInputEl.value.toLowerCase() : '';
                const filter = (filterSelectEl && filterSelectEl.value) ? filterSelectEl.value : 'all';
                
                // Filtrar convidados com verificações de segurança
                let filteredGuests = guests.filter(guest => {
                    // Verificar se guest é válido
                    if (!guest || !guest.nome || !guest.id) return false;
                    
                    const guestName = guest.nome.toLowerCase();
                    const guestCode = guest.codigo ? guest.codigo.toLowerCase() : '';
                    
                    const matchesSearch = guestName.includes(searchTerm) || guestCode.includes(searchTerm);
                    
                    if (filter === 'scanned') return matchesSearch && scannedGuests.has(guest.id);
                    if (filter === 'pending') return matchesSearch && !scannedGuests.has(guest.id);
                    return matchesSearch;
                });
                
                // Ordenar: escaneados primeiro, depois por nome
                filteredGuests.sort((a, b) => {
                    if (!a || !b || !a.nome || !b.nome) return 0;
                    
                    const aScanned = scannedGuests.has(a.id);
                    const bScanned = scannedGuests.has(b.id);
                    
                    if (aScanned && !bScanned) return -1;
                    if (!aScanned && bScanned) return 1;
                    return a.nome.localeCompare(b.nome);
                });
                
                if (filteredGuests.length === 0) {
                    guestTableBody.innerHTML = `
                        <tr>
                            <td colspan="2" class="text-center text-gray-500 py-8">
                                <i class="fas fa-search text-3xl mb-2"></i>
                                <p>Nenhum convidado encontrado</p>
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                // Renderizar lista com verificações de segurança
                guestTableBody.innerHTML = filteredGuests.map(guest => {
                    if (!guest || !guest.nome || !guest.id) return '';
                    
                    const isScanned = scannedGuests.has(guest.id);
                    const statusIcon = isScanned ? 'fa-check-circle text-green-600' : 'fa-clock text-yellow-600';
                    const statusText = isScanned ? 'Escaneado' : 'Pendente';
                    const rowClass = isScanned ? 'bg-green-50' : '';
                    
                    // Escapar HTML para prevenir XSS
                    const safeName = guest.nome.replace(/[<>&"']/g, function(match) {
                        const escapeMap = {
                            '<': '&lt;',
                            '>': '&gt;',
                            '&': '&amp;',
                            '"': '&quot;',
                            "'": '&#x27;'
                        };
                        return escapeMap[match];
                    });
                    
                    return `
                        <tr class="${rowClass} hover:bg-gray-50">
                            <td class="px-4 py-3 text-sm font-medium text-gray-900">${safeName}</td>
                            <td class="px-4 py-3 text-center">
                                <span class="inline-flex items-center text-sm">
                                    <i class="fas ${statusIcon} mr-2"></i>
                                    ${statusText}
                                </span>
                            </td>
                        </tr>
                    `;
                }).filter(row => row !== '').join('');
                
            } catch (error) {
                console.error('Erro ao renderizar lista de convidados:', error);
                const guestTableBody = document.getElementById('guestTableBody');
                if (guestTableBody) {
                    guestTableBody.innerHTML = `
                        <tr>
                            <td colspan="2" class="text-center text-red-500 py-8">
                                <i class="fas fa-exclamation-triangle text-3xl mb-2"></i>
                                <p>Erro ao carregar lista de convidados</p>
                            </td>
                        </tr>
                    `;
                }
            }
        }

        // Scanner QR Code - Inicialização automática

        async function startScanner() {
            try {
                html5QrCode = new Html5Qrcode("scannerContainer");
                
                await html5QrCode.start(
                    { facingMode: "environment" },
                    {
                        fps: 10,
                        qrbox: { width: 350, height: 350 }
                    },
                    onScanSuccess,
                    onScanFailure
                );
                
                isScanning = true;
                
            } catch (error) {
                console.error('Erro ao iniciar scanner:', error);
                scannerContainer.innerHTML = `
                    <div class="text-center text-red-400 px-6">
                        <i class="fas fa-exclamation-triangle text-5xl mb-4 text-red-500"></i>
                        <p class="text-lg font-medium">Erro ao acessar câmera</p>
                        <p class="text-sm mt-2 text-red-500">Verifique as permissões da câmera</p>
                    </div>
                `;
            }
        }

        function stopScanner() {
            if (html5QrCode) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    scannerContainer.innerHTML = `
                        <div class="text-center text-gray-400 px-6">
                            <i class="fas fa-qrcode text-5xl mb-4 text-gray-500"></i>
                            <p class="text-lg font-medium">Scanner parado</p>
                            <p class="text-sm mt-2 text-gray-500">Sem conexão com a internet</p>
                        </div>
                    `;
                });
            }
            
            isScanning = false;
        }

        async function onScanSuccess(decodedText) {
            // Se já processou um scan, pausar
            if (scanPaused) {
                return;
            }
            
            try {
                // Pausar scanner após primeiro scan
                scanPaused = true;
                
                // Pequena pausa para evitar múltiplos scans do mesmo QR
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verificar se dados básicos existem
                if (!decodedText || typeof decodedText !== 'string') {
                    showScanResult('CÓDIGO INVÁLIDO', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Verificar conexão
                if (!isOnline) {
                    showScanResult('SEM INTERNET', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Verificar se currentClient existe
                if (!currentClient || !currentClient.token) {
                    showScanResult('ERRO DE SESSÃO', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Verificar se guests é um array válido
                if (!Array.isArray(guests)) {
                    showScanResult('ERRO DE DADOS', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Procurar convidado pelo código (busca exata e segura)
                // IGNORAR DATA DE VALIDADE DOS QR CODES - apenas verificar o código base
                let cleanCode = decodedText.trim();
                
                // Se o QR code contém data/timestamp, extrair apenas o código base
                // Formatos comuns: "CODIGO_20241201", "CODIGO|2024-12-01", "CODIGO:timestamp"
                if (cleanCode.includes('_')) {
                    cleanCode = cleanCode.split('_')[0];
                } else if (cleanCode.includes('|')) {
                    cleanCode = cleanCode.split('|')[0];
                } else if (cleanCode.includes(':')) {
                    cleanCode = cleanCode.split(':')[0];
                }
                
                const guest = guests.find(g => {
                    // Verificar se o convidado e código são válidos
                    if (!g || !g.codigo || !g.id || !g.nome) return false;
                    
                    // Verificar se o código escaneado corresponde ao código do convidado (ignorando data)
                    let guestCode = g.codigo.trim();
                    if (guestCode.includes('_')) {
                        guestCode = guestCode.split('_')[0];
                    } else if (guestCode.includes('|')) {
                        guestCode = guestCode.split('|')[0];
                    } else if (guestCode.includes(':')) {
                        guestCode = guestCode.split(':')[0];
                    }
                    
                    return guestCode.toLowerCase() === cleanCode.toLowerCase();
                });
                
                if (!guest) {
                    // Registrar tentativa de código inválido no Supabase
                    try {
                        const { error: logError } = await supabaseClient
                            .from('logs')
                            .insert({
                                token: currentClient.token,
                                data: new Date().toISOString(),
                                status: 'codigo_invalido',
                                dispositivo: decodedText.trim()
                            });
                        
                        if (logError) {
                            console.error('Erro ao registrar código inválido:', logError);
                        }
                    } catch (error) {
                        console.error('Erro ao registrar log de código inválido:', error);
                    }
                    
                    showScanResult('CÓDIGO INVÁLIDO', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Verificar se já foi escaneado
                if (scannedGuests.has(guest.id)) {
                    // Registrar tentativa de re-scan no Supabase
                    try {
                        const { error: logError } = await supabaseClient
                            .from('logs')
                            .insert({
                                token: currentClient.token,
                                data: new Date().toISOString(),
                                status: 'ja_escaneado',
                                dispositivo: guest.codigo
                            });
                        
                        if (logError) {
                            console.error('Erro ao registrar tentativa duplicada:', logError);
                        }
                    } catch (error) {
                        console.error('Erro ao registrar log de tentativa duplicada:', error);
                    }
                    
                    showScanResult('JÁ ESCANEADO', guest.nome, 'warning');
                    playFeedback('warning');
                    showNextScanButton();
                    return;
                }
                
                // Verificar limite de scans
                const limit = currentClient?.limite_scans;
                const usedScans = currentClient?.scans_usados || 0;
                if (limit && usedScans >= limit) {
                    showScanResult('LIMITE ATINGIDO', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Verificar se Supabase está disponível
                if (!supabaseClient) {
                    showScanResult('ERRO DE SISTEMA', '', 'error');
                    playFeedback('error');
                    showNextScanButton();
                    return;
                }
                
                // Obter informações do dispositivo e IP
                const deviceInfo = getDeviceInfo();
                const userIP = await getUserIP();
                
                // Registrar scan na nova tabela de tempo real (prioritário)
                const { error: realtimeScanError } = await supabaseClient
                    .from('scans_realtime')
                    .insert({
                        codigo_convidado: guest.codigo,
                        token_cliente: currentClient.token,
                        data_scan: new Date().toISOString(),
                        dispositivo: deviceInfo,
                        ip_address: userIP
                    });
                
                if (realtimeScanError) {
                    console.error('Erro ao registrar scan em tempo real:', realtimeScanError);
                    // Continuar com fallback para logs antigos
                }
                
                // Registrar também no sistema de logs antigo (compatibilidade)
                const { error: logError } = await supabaseClient
                    .from('logs')
                    .insert({
                        token: currentClient.token,
                        data: new Date().toISOString(),
                        status: 'escaneado',
                        dispositivo: guest.codigo
                    });
                
                if (logError) {
                    console.error('Erro ao registrar log:', logError);
                    // Se ambos falharam, mostrar erro
                    if (realtimeScanError) {
                        throw new Error('Erro ao registrar scan');
                    }
                }
                
                // Atualizar contador de scans usados no cliente
                const { error: updateError } = await supabaseClient
                    .from('clientes')
                    .update({ 
                        scans_usados: (currentClient.scans_usados || 0) + 1 
                    })
                    .eq('token', currentClient.token);
                
                if (updateError) {
                    console.error('Erro ao atualizar contador:', updateError);
                    // Não falhar por este erro, continuar
                }
                
                // Atualizar status do convidado
                const { error: guestError } = await supabaseClient
                    .from('convidados')
                    .update({ status: 'escaneado' })
                    .eq('id', guest.id);
                
                if (guestError) {
                    console.error('Erro ao atualizar convidado:', guestError);
                    // Não falhar por este erro, continuar
                }
                
                // Atualizar estado local
                currentClient.scans_usados = (currentClient.scans_usados || 0) + 1;
                scannedGuests.add(guest.id);
                lastScanResult = { guest, success: true };
                
                // Atualizar interface
                setTimeout(() => {
                    updateUI();
                    checkMilestones();
                }, 100);
                
                showScanResult('PERMITIDO', guest.nome, 'success');
                playFeedback('success');
                
                // Mostrar botão próximo
                showNextScanButton();
                
            } catch (error) {
                console.error('Erro ao processar scan:', error);
                showScanResult('ERRO DE SISTEMA', '', 'error');
                playFeedback('error');
                showNextScanButton();
            }
        }

        // Mostrar botão próximo (mobile-friendly)
        function showNextScanButton() {
            const mobileActions = document.getElementById('mobileBottomActions');
            if (mobileActions) {
                mobileActions.classList.remove('hidden');
            }
        }
        
        // Esconder botão próximo
        function hideNextScanButton() {
            const mobileActions = document.getElementById('mobileBottomActions');
            if (mobileActions) {
                mobileActions.classList.add('hidden');
            }
        }

        // Feedback sonoro e vibração
        function playFeedback(type) {
            // Vibração
            if (settings.vibrationEnabled && navigator.vibrate) {
                const patterns = {
                    success: [200],
                    warning: [100, 100, 100],
                    error: [300, 100, 300]
                };
                navigator.vibrate(patterns[type] || [200]);
            }
            
            // Som (simulado com Web Audio API)
            if (settings.soundEnabled) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    const frequencies = {
                        success: 800,
                        warning: 600,
                        error: 400
                    };
                    
                    oscillator.frequency.setValueAtTime(frequencies[type] || 600, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (error) {
                    // Ignorar erros de áudio
                }
            }
        }

        function onScanFailure(error) {
            // Ignorar erros de scan (muito verboso)
        }

        function showScanResult(status, guestName, type) {
            const styles = {
                success: {
                    bg: 'bg-gradient-to-r from-green-50 to-emerald-50',
                    border: 'border-l-green-500',
                    text: 'text-green-800',
                    icon: 'fas fa-check-circle text-green-500',
                    shadow: 'shadow-green-200',
                    animation: 'feedback-success'
                },
                error: {
                    bg: 'bg-gradient-to-r from-red-50 to-rose-50',
                    border: 'border-l-red-500',
                    text: 'text-red-800',
                    icon: 'fas fa-times-circle text-red-500',
                    shadow: 'shadow-red-200',
                    animation: 'feedback-error'
                },
                warning: {
                    bg: 'bg-gradient-to-r from-yellow-50 to-amber-50',
                    border: 'border-l-yellow-500',
                    text: 'text-yellow-800',
                    icon: 'fas fa-exclamation-triangle text-yellow-500',
                    shadow: 'shadow-yellow-200',
                    animation: 'feedback-warning'
                }
            };
            
            const style = styles[type];
            const scanResultPlaceholder = document.getElementById('scanResultPlaceholder');
            
            // Esconder placeholder
            scanResultPlaceholder.classList.add('hidden');
            
            scanResult.className = `p-4 rounded-lg text-center border-l-4 transform transition-all duration-300 ${style.bg} ${style.border} ${style.text} ${style.shadow} ${style.animation}`;
            
            // Humanized messages com detecção de plural
            let humanizedMessage = '';
            const isPlural = guestName ? detectPlural(guestName) : false;
            
            if (type === 'success' && guestName) {
                if (isPlural) {
                    humanizedMessage = `✅ Entrada confirmada para ${guestName}`;
                } else {
                    humanizedMessage = `✅ Entrada confirmada para ${guestName}`;
                }
            } else if (type === 'warning' && guestName) {
                if (isPlural) {
                    humanizedMessage = `⚠️ ${guestName} já entraram anteriormente`;
                } else {
                    humanizedMessage = `⚠️ ${guestName} já entrou anteriormente`;
                }
            } else if (type === 'error') {
                if (status === 'CÓDIGO INVÁLIDO') {
                    humanizedMessage = '❌ QR inválido — verifique novamente';
                } else if (status === 'JÁ ESCANEADO') {
                    if (isPlural) {
                        humanizedMessage = `⚠️ ${guestName} já entraram anteriormente`;
                    } else {
                        humanizedMessage = `⚠️ ${guestName} já entrou anteriormente`;
                    }
                } else if (status === 'LIMITE ATINGIDO') {
                    humanizedMessage = '🚫 Limite de entradas atingido';
                } else if (status === 'SEM INTERNET') {
                    humanizedMessage = '📶 Sem conexão — tente novamente';
                } else {
                    humanizedMessage = '❌ Erro no sistema — contacte suporte';
                }
            }
            
            if (humanizedMessage) {
                scanResult.innerHTML = `
                    <div class="flex items-center justify-center mb-3">
                        <i class="${style.icon} text-3xl"></i>
                    </div>
                    <div class="text-lg font-bold">${humanizedMessage}</div>
                `;
            } else {
                // Fallback para casos não cobertos
                scanResult.innerHTML = `
                    <div class="flex items-center justify-center mb-3">
                        <i class="${style.icon} text-3xl"></i>
                    </div>
                    <div class="text-xl font-bold">${status}</div>
                    ${guestName ? `<div class="text-sm font-medium opacity-80">${guestName}</div>` : ''}
                `;
            }
            
            scanResult.classList.remove('hidden');
        }

        // Busca e filtros - com verificação de segurança
        if (searchInput) {
            searchInput.addEventListener('input', renderGuestList);
        }
        if (filterSelect) {
            filterSelect.addEventListener('change', renderGuestList);
        }

        // Sincronizar dados
        syncBtn.addEventListener('click', async () => {
            if (!isOnline) {
                showNotification('Sem conexão para sincronizar', 'error');
                return;
            }
            
            syncBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Sincronizando...';
            try {
                await loadSession();
                showNotification('Dados sincronizados com sucesso!', 'success');
            } catch (error) {
                showNotification('Erro ao sincronizar dados', 'error');
            } finally {
                syncBtn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Sincronizar Dados';
            }
        });

        // Exportar relatório em PDF
        exportBtn.addEventListener('click', async () => {
            if (!isOnline) {
                showNotification('Sem conexão para exportar relatório', 'error');
                return;
            }
            
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-3"></i>Gerando PDF...';
            
            try {
                await generatePDFReport();
                showNotification('Relatório PDF gerado com sucesso!', 'success');
            } catch (error) {
                console.error('Erro ao gerar PDF:', error);
                showNotification('Erro ao gerar relatório PDF', 'error');
            } finally {
                exportBtn.innerHTML = '<i class="fas fa-download mr-3"></i>Exportar';
            }
        });

        // Desfazer todos os escaneados
        document.getElementById('undoScansBtn').addEventListener('click', async () => {
            if (!isOnline) {
                showNotification('Sem conexão para desfazer escaneados', 'error');
                return;
            }
            
            if (undoUsagesRemaining <= 0) {
                showNotification('Limite de utilizações do botão desfazer atingido', 'error');
                return;
            }
            
            if (scannedGuests.size === 0) {
                showNotification('Não há escaneados para desfazer', 'warning');
                return;
            }
            
            // Mostrar confirmação
            const confirmed = confirm(`⚠️ ATENÇÃO!\n\nTem a certeza que deseja desfazer TODOS os ${scannedGuests.size} escaneados?\n\nEsta ação:\n• Remove todos os registos de entrada\n• Não pode ser desfeita\n• Só pode usar esta função ${undoUsagesRemaining} vez(es)\n\nDeseja continuar?`);
            
            if (!confirmed) {
                return;
            }
            
            const undoBtn = document.getElementById('undoScansBtn');
            undoBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-3"></i>Desfazendo...';
            undoBtn.disabled = true;
            
            try {
                // Verificar se Supabase está disponível
                if (!supabaseClient || !currentClient) {
                    throw new Error('Sistema não inicializado');
                }
                
                // Remover todos os scans em tempo real (nova tabela)
                const { error: deleteRealtimeError } = await supabaseClient
                    .from('scans_realtime')
                    .delete()
                    .eq('token_cliente', currentClient.token);
                
                if (deleteRealtimeError) {
                    console.error('Erro ao remover scans em tempo real:', deleteRealtimeError);
                }
                
                // Remover todos os logs de escaneados (compatibilidade)
                const { error: deleteLogsError } = await supabaseClient
                    .from('logs')
                    .delete()
                    .eq('token', currentClient.token)
                    .eq('status', 'escaneado');
                
                if (deleteLogsError) {
                    console.error('Erro ao remover logs:', deleteLogsError);
                    // Se ambos falharam, mostrar erro
                    if (deleteRealtimeError) {
                        throw new Error('Erro ao remover registos de entrada');
                    }
                }
                
                // Atualizar status de todos os convidados para pendente
                const scannedGuestIds = Array.from(scannedGuests);
                if (scannedGuestIds.length > 0) {
                    const { error: updateGuestsError } = await supabaseClient
                        .from('convidados')
                        .update({ status: 'pendente' })
                        .in('id', scannedGuestIds);
                    
                    if (updateGuestsError) {
                        console.error('Erro ao atualizar convidados:', updateGuestsError);
                        // Não falhar por este erro, continuar
                    }
                }
                
                // Resetar contador de scans usados
                const { error: resetCounterError } = await supabaseClient
                    .from('clientes')
                    .update({ scans_usados: 0 })
                    .eq('token', currentClient.token);
                
                if (resetCounterError) {
                    console.error('Erro ao resetar contador:', resetCounterError);
                    // Não falhar por este erro, continuar
                }
                
                // Atualizar contador de usos restantes no Supabase
                undoUsagesRemaining--;
                const { error: updateUndoError } = await supabaseClient
                    .from('clientes')
                    .update({ undo_usages_remaining: undoUsagesRemaining })
                    .eq('token', currentClient.token);
                
                if (updateUndoError) {
                    console.error('Erro ao atualizar contador de desfazer:', updateUndoError);
                    // Reverter mudança local se falhou no Supabase
                    undoUsagesRemaining++;
                    throw new Error('Erro ao atualizar limite de utilizações');
                }
                
                // Atualizar estado local
                const totalUndone = scannedGuests.size;
                scannedGuests.clear();
                currentClient.scans_usados = 0;
                
                // Atualizar interface
                updateUI();
                updateUndoButton();
                
                showNotification(`✅ ${totalUndone} escaneados foram desfeitos com sucesso!`, 'success');
                
                // Registar ação de desfazer no log com informações de segurança
                try {
                    await supabaseClient
                        .from('logs')
                        .insert({
                            token: currentClient.token,
                            data: new Date().toISOString(),
                            status: 'acao_desfazer',
                            dispositivo: `${totalUndone}_escaneados_desfeitos_usos_restantes_${undoUsagesRemaining}`
                        });
                } catch (logError) {
                    console.error('Erro ao registar ação de desfazer:', logError);
                }
                
            } catch (error) {
                console.error('Erro ao desfazer escaneados:', error);
                showNotification('Erro ao desfazer escaneados: ' + error.message, 'error');
            } finally {
                undoBtn.innerHTML = '<i class="fas fa-undo mr-3"></i>Desfazer';
                undoBtn.disabled = false;
            }
        });

        // Atualizar estado do botão desfazer
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoScansBtn');
            const undoInfo = document.getElementById('undoUsageInfo');
            const undoUsagesLeftEl = document.getElementById('undoUsagesLeft');
            
            if (undoUsagesLeftEl) {
                undoUsagesLeftEl.textContent = undoUsagesRemaining;
            }
            
            if (undoUsagesRemaining <= 0) {
                if (undoBtn) {
                    undoBtn.style.display = 'none';
                }
                if (undoInfo) {
                    undoInfo.innerHTML = '<i class="fas fa-ban mr-1 text-red-500"></i><span class="text-red-600">Limite de utilizações do botão desfazer atingido</span>';
                }
            } else {
                if (undoBtn) {
                    undoBtn.style.display = 'flex';
                }
                if (undoInfo) {
                    const color = undoUsagesRemaining === 1 ? 'text-red-600' : 'text-gray-600';
                    undoInfo.innerHTML = `<i class="fas fa-info-circle mr-1"></i><span class="${color}">Restam <span id="undoUsagesLeft">${undoUsagesRemaining}</span> utilizações do botão desfazer</span>`;
                }
            }
        }

        // Função para gerar relatório PDF profissional
        async function generatePDFReport() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Carregar dados detalhados dos scans (nova tabela + logs antigos)
            let scanLogs = [];
            let scanAttempts = {};
            let deviceStats = {};
            
            if (supabaseClient && currentClient) {
                try {
                    // Carregar scans em tempo real (dados mais ricos)
                    const { data: realtimeData } = await supabaseClient
                        .from('scans_realtime')
                        .select('*')
                        .eq('token_cliente', currentClient.token)
                        .order('data_scan', { ascending: true });
                    
                    // Carregar logs antigos para compatibilidade
                    const { data: logData } = await supabaseClient
                        .from('logs')
                        .select('*')
                        .eq('token', currentClient.token)
                        .order('data', { ascending: true });
                    
                    // Processar scans em tempo real
                    if (realtimeData && realtimeData.length > 0) {
                        realtimeData.forEach(scan => {
                            if (scan.codigo_convidado) {
                                // Estatísticas por código
                                if (!scanAttempts[scan.codigo_convidado]) {
                                    scanAttempts[scan.codigo_convidado] = {
                                        total: 0,
                                        successful: 0,
                                        duplicated: 0,
                                        invalid: 0,
                                        firstScan: null,
                                        lastAttempt: null,
                                        hasSuccess: false,
                                        devices: new Set(),
                                        ips: new Set()
                                    };
                                }
                                
                                scanAttempts[scan.codigo_convidado].total++;
                                scanAttempts[scan.codigo_convidado].successful++;
                                scanAttempts[scan.codigo_convidado].hasSuccess = true;
                                scanAttempts[scan.codigo_convidado].lastAttempt = new Date(scan.data_scan);
                                
                                if (!scanAttempts[scan.codigo_convidado].firstScan) {
                                    scanAttempts[scan.codigo_convidado].firstScan = new Date(scan.data_scan);
                                }
                                
                                // Rastrear dispositivos e IPs únicos
                                if (scan.dispositivo) {
                                    scanAttempts[scan.codigo_convidado].devices.add(scan.dispositivo);
                                }
                                if (scan.ip_address) {
                                    scanAttempts[scan.codigo_convidado].ips.add(scan.ip_address);
                                }
                                
                                // Estatísticas por dispositivo
                                if (scan.dispositivo) {
                                    if (!deviceStats[scan.dispositivo]) {
                                        deviceStats[scan.dispositivo] = {
                                            scans: 0,
                                            uniqueGuests: new Set(),
                                            ips: new Set()
                                        };
                                    }
                                    deviceStats[scan.dispositivo].scans++;
                                    deviceStats[scan.dispositivo].uniqueGuests.add(scan.codigo_convidado);
                                    if (scan.ip_address) {
                                        deviceStats[scan.dispositivo].ips.add(scan.ip_address);
                                    }
                                }
                            }
                        });
                        
                        scanLogs = realtimeData.map(scan => ({
                            data: scan.data_scan,
                            status: 'escaneado',
                            dispositivo: scan.codigo_convidado,
                            device_info: scan.dispositivo,
                            ip_address: scan.ip_address
                        }));
                    }
                    
                    // Processar logs antigos (fallback e dados adicionais)
                    if (logData) {
                        logData.forEach(log => {
                            if (log.dispositivo) {
                                if (!scanAttempts[log.dispositivo]) {
                                    scanAttempts[log.dispositivo] = {
                                        total: 0,
                                        successful: 0,
                                        duplicated: 0,
                                        invalid: 0,
                                        firstScan: null,
                                        lastAttempt: null,
                                        hasSuccess: false,
                                        devices: new Set(),
                                        ips: new Set()
                                    };
                                }
                                
                                scanAttempts[log.dispositivo].total++;
                                scanAttempts[log.dispositivo].lastAttempt = new Date(log.data);
                                
                                if (log.status === 'escaneado') {
                                    scanAttempts[log.dispositivo].successful++;
                                    if (!scanAttempts[log.dispositivo].firstScan) {
                                        scanAttempts[log.dispositivo].firstScan = new Date(log.data);
                                        scanAttempts[log.dispositivo].hasSuccess = true;
                                    }
                                } else if (log.status === 'ja_escaneado') {
                                    scanAttempts[log.dispositivo].duplicated++;
                                } else if (log.status === 'codigo_invalido') {
                                    scanAttempts[log.dispositivo].invalid++;
                                }
                            }
                        });
                        
                        // Se não há dados em tempo real, usar logs antigos
                        if (!realtimeData || realtimeData.length === 0) {
                            scanLogs = logData;
                        }
                    }
                    
                } catch (error) {
                    console.error('Erro ao carregar dados para relatório:', error);
                }
            }
            
            const now = new Date();
            const scannedCount = scannedGuests.size;
            const totalGuests = guests.length;
            const notAttended = totalGuests - scannedCount;
            const attendanceRate = totalGuests > 0 ? ((scannedCount / totalGuests) * 100).toFixed(1) : 0;
            
            // Configurações de estilo
            const primaryColor = [37, 99, 235]; // Azul
            const secondaryColor = [107, 114, 128]; // Cinza
            const successColor = [34, 197, 94]; // Verde
            const warningColor = [245, 158, 11]; // Amarelo
            
            // Cabeçalho
            doc.setFillColor(...primaryColor);
            doc.rect(0, 0, 210, 40, 'F');
            
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.text('RELATÓRIO DE CONTROLE DE ACESSO', 105, 20, { align: 'center' });
            
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text(`Gerado em ${now.toLocaleDateString('pt-BR')} às ${now.toLocaleTimeString('pt-BR')}`, 105, 30, { align: 'center' });
            
            // Informações do evento
            let yPos = 55;
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('INFORMAÇÕES DO EVENTO', 20, yPos);
            
            yPos += 10;
            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            doc.text(`Nome do Evento: ${currentClient.nome || 'Não informado'}`, 20, yPos);
            yPos += 6;
            doc.text(`Token: ${currentClient.token}`, 20, yPos);
            yPos += 6;
            doc.text(`Data do Relatório: ${now.toLocaleDateString('pt-BR')} ${now.toLocaleTimeString('pt-BR')}`, 20, yPos);
            
            // Estatísticas principais
            yPos += 20;
            doc.setFillColor(248, 250, 252);
            doc.rect(15, yPos - 5, 180, 35, 'F');
            
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('RESUMO ESTATÍSTICO', 20, yPos + 5);
            
            yPos += 15;
            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            
            // Primeira linha de estatísticas
            doc.text(`Total de Convidados: ${totalGuests}`, 20, yPos);
            doc.setTextColor(...successColor);
            doc.text(`Compareceram: ${scannedCount}`, 75, yPos);
            doc.setTextColor(220, 38, 38);
            doc.text(`Não Compareceram: ${notAttended}`, 130, yPos);
            
            yPos += 8;
            doc.setTextColor(0, 0, 0);
            doc.text(`Taxa de Comparecimento: ${attendanceRate}%`, 20, yPos);
            
            // Gráfico de barras simples
            yPos += 20;
            const barWidth = 150;
            const barHeight = 8;
            const attendedWidth = (scannedCount / totalGuests) * barWidth;
            
            // Barra de fundo
            doc.setFillColor(229, 231, 235);
            doc.rect(20, yPos, barWidth, barHeight, 'F');
            
            // Barra de progresso
            if (attendedWidth > 0) {
                doc.setFillColor(...successColor);
                doc.rect(20, yPos, attendedWidth, barHeight, 'F');
            }
            
            doc.setFontSize(9);
            doc.text(`${attendanceRate}%`, 175, yPos + 5);
            
            // Lista detalhada de convidados
            yPos += 25;
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('LISTA DETALHADA DE CONVIDADOS', 20, yPos);
            
            yPos += 10;
            
            // Cabeçalho da tabela com layout otimizado
            doc.setFillColor(...primaryColor);
            doc.rect(15, yPos, 180, 10, 'F');
            
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            
            // Definir posições das colunas otimizadas
            const colPositions = {
                nome: 18,      // 70 unidades de largura
                status: 88,    // 25 unidades de largura  
                tentativas: 113, // 15 unidades de largura
                horario: 128   // 67 unidades de largura
            };
            
            doc.text('NOME DO CONVIDADO', colPositions.nome, yPos + 6);
            doc.text('STATUS', colPositions.status, yPos + 6);
            doc.text('TENT.', colPositions.tentativas, yPos + 6);
            doc.text('PRIMEIRO ACESSO', colPositions.horario, yPos + 6);
            
            yPos += 14;
            
            // Dados dos convidados com layout otimizado
            doc.setTextColor(0, 0, 0);
            doc.setFont('helvetica', 'normal');
            
            guests.forEach((guest, index) => {
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 20;
                    
                    // Repetir cabeçalho na nova página
                    doc.setFillColor(...primaryColor);
                    doc.rect(15, yPos, 180, 10, 'F');
                    
                    doc.setTextColor(255, 255, 255);
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.text('NOME DO CONVIDADO', colPositions.nome, yPos + 6);
                    doc.text('STATUS', colPositions.status, yPos + 6);
                    doc.text('TENT.', colPositions.tentativas, yPos + 6);
                    doc.text('PRIMEIRO ACESSO', colPositions.horario, yPos + 6);
                    
                    yPos += 14;
                    doc.setTextColor(0, 0, 0);
                    doc.setFont('helvetica', 'normal');
                }
                
                const isScanned = scannedGuests.has(guest.id);
                const attempts = scanAttempts[guest.codigo];
                const attemptCount = attempts ? attempts.total : 0;
                
                // Cor de fundo alternada
                if (index % 2 === 0) {
                    doc.setFillColor(249, 250, 251);
                    doc.rect(15, yPos - 2, 180, 8, 'F');
                }
                
                // Nome do convidado (máximo 30 caracteres)
                doc.setFontSize(7);
                doc.setTextColor(0, 0, 0);
                const maxNameLength = 30;
                const displayName = guest.nome.length > maxNameLength ? 
                    guest.nome.substring(0, maxNameLength) + '...' : guest.nome;
                doc.text(displayName, colPositions.nome, yPos + 3);
                
                // Status
                doc.setFontSize(7);
                if (isScanned) {
                    doc.setTextColor(...successColor);
                    doc.text('PRESENTE', colPositions.status, yPos + 3);
                } else {
                    doc.setTextColor(220, 38, 38);
                    doc.text('AUSENTE', colPositions.status, yPos + 3);
                }
                
                // Tentativas
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(7);
                doc.text(attemptCount.toString(), colPositions.tentativas, yPos + 3);
                
                // Primeiro acesso - formato otimizado
                doc.setFontSize(6);
                if (attempts && attempts.firstScan) {
                    const date = attempts.firstScan;
                    const dateStr = date.toLocaleDateString('pt-BR', { 
                        day: '2-digit', 
                        month: '2-digit' 
                    });
                    const timeStr = date.toLocaleTimeString('pt-BR', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    const fullDateTime = `${dateStr} ${timeStr}`;
                    doc.text(fullDateTime, colPositions.horario, yPos + 3);
                } else {
                    doc.setTextColor(150, 150, 150);
                    doc.text('Não compareceu', colPositions.horario, yPos + 3);
                    doc.setTextColor(0, 0, 0);
                }
                
                yPos += 8;
            });
            
            // Análise de tentativas múltiplas
            const multipleAttempts = Object.entries(scanAttempts)
                .filter(([code, data]) => data.total > 1)
                .sort((a, b) => b[1].total - a[1].total);
            
            const invalidAttempts = Object.entries(scanAttempts)
                .filter(([code, data]) => data.invalid > 0)
                .sort((a, b) => b[1].invalid - a[1].invalid);
            
            if (multipleAttempts.length > 0 || invalidAttempts.length > 0) {
                yPos += 15;
                if (yPos > 230) {
                    doc.addPage();
                    yPos = 20;
                }
                
                doc.setFontSize(16);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text('ANÁLISE DETALHADA DE TENTATIVAS', 20, yPos);
                
                // Tentativas múltiplas
                if (multipleAttempts.length > 0) {
                    yPos += 12;
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...warningColor);
                    doc.text('CÓDIGOS COM MÚLTIPLAS TENTATIVAS:', 20, yPos);
                    
                    yPos += 8;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`${multipleAttempts.length} código(s) tentaram acesso mais de uma vez:`, 20, yPos);
                    
                    yPos += 6;
                    multipleAttempts.slice(0, 15).forEach(([code, data]) => {
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        const guest = guests.find(g => g.codigo === code);
                        const guestName = guest ? guest.nome : `Código: ${code}`;
                        const maxNameLength = 30;
                        const displayName = guestName.length > maxNameLength ? 
                            guestName.substring(0, maxNameLength) + '...' : guestName;
                        
                        doc.setFontSize(8);
                        doc.text(`• ${displayName}:`, 25, yPos);
                        doc.text(`${data.total} tentativas`, 120, yPos);
                        
                        if (data.duplicated > 0) {
                            doc.setTextColor(...warningColor);
                            doc.text(`(${data.duplicated} duplicadas)`, 155, yPos);
                            doc.setTextColor(0, 0, 0);
                        }
                        
                        yPos += 4;
                    });
                }
                
                // Códigos inválidos
                if (invalidAttempts.length > 0) {
                    yPos += 10;
                    if (yPos > 250) {
                        doc.addPage();
                        yPos = 20;
                    }
                    
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(220, 38, 38);
                    doc.text('TENTATIVAS COM CÓDIGOS INVÁLIDOS:', 20, yPos);
                    
                    yPos += 8;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`${invalidAttempts.length} código(s) inválido(s) foram escaneados:`, 20, yPos);
                    
                    yPos += 6;
                    invalidAttempts.slice(0, 10).forEach(([code, data]) => {
                        if (yPos > 270) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        doc.setFontSize(8);
                        doc.text(`• Código: ${code}`, 25, yPos);
                        doc.text(`${data.invalid} tentativa(s)`, 120, yPos);
                        
                        if (data.lastAttempt) {
                            doc.text(`Última: ${data.lastAttempt.toLocaleString('pt-BR')}`, 25, yPos + 3);
                            yPos += 3;
                        }
                        
                        yPos += 5;
                    });
                }
            }
            
            // Rodapé
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(...secondaryColor);
                doc.text(`Página ${i} de ${pageCount}`, 105, 290, { align: 'center' });
                doc.text('Relatório gerado automaticamente pelo Sistema de Controle de Acesso', 105, 295, { align: 'center' });
            }
            
            // Salvar PDF
            const fileName = `relatorio_${currentClient.nome.replace(/[^a-zA-Z0-9]/g, '_')}_${now.toISOString().split('T')[0]}.pdf`;
            doc.save(fileName);
        }

        // Botão próximo scan
        nextScanBtn.addEventListener('click', () => {
            scanPaused = false;
            hideNextScanButton();
            scanResult.classList.add('hidden');
            document.getElementById('scanResultPlaceholder').classList.remove('hidden');
        });

        // Event listeners para configurações
        document.getElementById('soundToggle').addEventListener('change', (e) => {
            settings.soundEnabled = e.target.checked;
            localStorage.setItem('scannerSettings', JSON.stringify(settings));
            showNotification(settings.soundEnabled ? 'Som ativado' : 'Som desativado', 'info');
        });

        document.getElementById('vibrationToggle').addEventListener('change', (e) => {
            settings.vibrationEnabled = e.target.checked;
            localStorage.setItem('scannerSettings', JSON.stringify(settings));
            showNotification(settings.vibrationEnabled ? 'Vibração ativada' : 'Vibração desativada', 'info');
        });

        document.getElementById('notificationsToggle').addEventListener('change', (e) => {
            settings.notificationsEnabled = e.target.checked;
            localStorage.setItem('scannerSettings', JSON.stringify(settings));
            
            // Mostrar notificação apenas se as notificações estão sendo ativadas
            if (settings.notificationsEnabled) {
                showNotification('Notificações ativadas', 'info');
            }
        });



        // Função para resetar configurações
        function resetSettings() {
            settings = {
                soundEnabled: true,
                vibrationEnabled: true,
                notificationsEnabled: true
            };
            
            // Atualizar interface (verificar se elementos existem)
            const soundToggle = document.getElementById('soundToggle');
            const vibrationToggle = document.getElementById('vibrationToggle');
            const notificationsToggle = document.getElementById('notificationsToggle');
            
            if (soundToggle) soundToggle.checked = settings.soundEnabled;
            if (vibrationToggle) vibrationToggle.checked = settings.vibrationEnabled;
            if (notificationsToggle) notificationsToggle.checked = settings.notificationsEnabled;
            
            // Salvar
            localStorage.setItem('scannerSettings', JSON.stringify(settings));
        }

        // Função para carregar configurações salvas
        function loadSettings() {
            const savedSettings = localStorage.getItem('scannerSettings');
            if (savedSettings) {
                settings = { ...settings, ...JSON.parse(savedSettings) };
                
                // Atualizar interface (verificar se elementos existem)
                const soundToggle = document.getElementById('soundToggle');
                const vibrationToggle = document.getElementById('vibrationToggle');
                const notificationsToggle = document.getElementById('notificationsToggle');
                
                if (soundToggle) soundToggle.checked = settings.soundEnabled;
                if (vibrationToggle) vibrationToggle.checked = settings.vibrationEnabled;
                if (notificationsToggle) notificationsToggle.checked = settings.notificationsEnabled;
            }
        }

        // Logout
        function logout() {
            if (isScanning) stopScanner();
            stopMonitoring();
            currentClient = null;
            guests = [];
            scannedGuests.clear();
            scanPaused = false;
            undoUsagesRemaining = 3; // Reset local, mas será carregado do Supabase no próximo login
            
            // Manter token mascarado após logout
            const savedToken = localStorage.getItem('eventToken');
            if (savedToken) {
                realToken = savedToken;
                tokenInput.value = '********';
                tokenInput.style.color = '#6b7280';
                tokenInput.style.fontFamily = 'monospace';
                
                // Adicionar texto de ajuda se não existir
                let helpText = document.getElementById('tokenHelp');
                if (!helpText) {
                    helpText = document.createElement('p');
                    helpText.id = 'tokenHelp';
                    helpText.className = 'text-xs text-gray-500 mt-1';
                    helpText.innerHTML = '<i class="fas fa-info-circle mr-1"></i>Token guardado - clique em Entrar';
                    tokenInput.parentNode.appendChild(helpText);
                }
            }
            
            loginScreen.classList.remove('hidden');
            mainApp.classList.add('hidden');
        }

        logoutBtn.addEventListener('click', logout);

        // Função para alternar seções colapsáveis
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            
            if (section.classList.contains('hidden')) {
                section.classList.remove('hidden');
                icon.classList.add('rotate-180');
            } else {
                section.classList.add('hidden');
                icon.classList.remove('rotate-180');
            }
        }

        // Event listeners das abas serão adicionados na inicialização

        // Variável para armazenar o token real
        let realToken = null;

        // Prevent zoom and orientation changes on mobile
        function preventMobileInterference() {
            // Prevent double-tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
            // Lock orientation to portrait on mobile (if supported)
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(() => {
                    // Orientation lock not supported or failed, continue normally
                });
            }
            
            // Prevent context menu on long press
            document.addEventListener('contextmenu', function(e) {
                if (e.target.closest('.scanner-container')) {
                    e.preventDefault();
                }
            });
            
            // Prevent text selection in scanner area
            document.addEventListener('selectstart', function(e) {
                if (e.target.closest('.scanner-container')) {
                    e.preventDefault();
                }
            });
        }

        // Inicialização
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Initialize mobile optimizations
                preventMobileInterference();
                // Inicializar elementos das abas com verificação de segurança
                scannerTab = document.getElementById('scannerTab');
                scannerTabContent = document.getElementById('scannerTabContent');
                quickScanBtn = document.getElementById('quickScanBtn');
                refreshDataBtn = document.getElementById('refreshDataBtn');
                progressBar = document.getElementById('progressBar');
                progressText = document.getElementById('progressText');
                scannerProgressBar = document.getElementById('scannerProgressBar');
                scannerProgressText = document.getElementById('scannerProgressText');
                scannerScannedCount = document.getElementById('scannerScannedCount');
                scannerTotalGuestCount = document.getElementById('scannerTotalGuestCount');
                optionsTab = document.getElementById('optionsTab');
                optionsTabContent = document.getElementById('optionsTabContent');
                
                // Atualizar ano automaticamente
                const currentYearEl = document.getElementById('currentYear');
                if (currentYearEl) {
                    currentYearEl.textContent = new Date().getFullYear();
                }
                
                // Carregar token salvo automaticamente
                const savedToken = localStorage.getItem('eventToken');
                if (savedToken && tokenInput) {
                    realToken = savedToken;
                    tokenInput.value = '********';
                    tokenInput.style.color = '#6b7280';
                    tokenInput.style.fontFamily = 'monospace';
                    
                    // Adicionar texto de ajuda
                    const helpText = document.createElement('p');
                    helpText.id = 'tokenHelp';
                    helpText.className = 'text-xs text-gray-500 mt-1';
                    helpText.innerHTML = '<i class="fas fa-info-circle mr-1"></i>Token guardado - clique em Entrar';
                    if (tokenInput.parentNode) {
                        tokenInput.parentNode.appendChild(helpText);
                    }
                }
                
                // Controlar comportamento do campo de token
                if (tokenInput) {
                    tokenInput.addEventListener('focus', () => {
                        if (tokenInput.value === '********' && realToken) {
                            tokenInput.value = '';
                            tokenInput.style.color = '#374151';
                            tokenInput.style.fontFamily = 'Inter, sans-serif';
                            realToken = null; // Limpar token salvo se usuário começar a digitar
                            
                            // Remover texto de ajuda
                            const helpText = document.getElementById('tokenHelp');
                            if (helpText) helpText.remove();
                        }
                    });
                    
                    tokenInput.addEventListener('input', () => {
                        if (realToken && tokenInput.value !== '********') {
                            realToken = null; // Limpar token salvo se usuário digitar algo
                            
                            // Remover texto de ajuda
                            const helpText = document.getElementById('tokenHelp');
                            if (helpText) helpText.remove();
                        }
                    });
                }
                
                // Event listeners das abas
                if (scannerTab) scannerTab.addEventListener('click', () => switchTab('scanner'));
                if (optionsTab) optionsTab.addEventListener('click', () => switchTab('options'));
                
                // Botão de ação rápida para ir ao scanner
                if (quickScanBtn) quickScanBtn.addEventListener('click', () => switchTab('scanner'));
                
                // Botão de atualizar dados
                if (refreshDataBtn) {
                    refreshDataBtn.addEventListener('click', async () => {
                        if (!isOnline) {
                            return; // Não fazer nada se offline, botão já está desabilitado
                        }
                        
                        refreshDataBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Atualizando...';
                        try {
                            await loadSession();
                            showNotification('Dados atualizados com sucesso!', 'success');
                        } catch (error) {
                            showNotification('Erro ao atualizar dados', 'error');
                        } finally {
                            refreshDataBtn.innerHTML = '<i class="fas fa-refresh mr-2"></i>Atualizar';
                        }
                    });
                }
                
                // Carregar configurações salvas
                loadSettings();
                
                // Inicializar na aba do scanner
                switchTab('scanner');
                
            } catch (error) {
                console.error('Erro na inicialização:', error);
                // Tentar novamente após um pequeno delay
                setTimeout(() => {
                    try {
                        switchTab('scanner');
                    } catch (e) {
                        console.error('Erro na inicialização das abas:', e);
                    }
                }, 500);
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96f9e51cf50177da',t:'MTc1NTI3MzUyMy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
